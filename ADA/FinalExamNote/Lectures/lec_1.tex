\chapter{All-pairs distances problem}
\lecture{1}{13 Nov.}{}
\begin{problem}
\vphantom{text}
\begin{itemize}
  \item Input: an edge-weighted directed graph \(G\) with \(V(G)=\left\{ 1, 2, \dots , n \right\} \) that \textcolor{red}{has no cycle of negative weight.} 
  \item Output: \textcolor{red}{\(d_G(i, j)\)} for all vertices \(i\) and \(j\) of \(G\).     
\end{itemize}
\end{problem}

\begin{remark}
  Here we suppose \(G\) has no negative cycle to simplify the problem. 
\end{remark}

The Naive algorithm is to solve \(n\) single-source distances problems directly. Hence, the time complexity for using different algorithm is:
\begin{itemize}
  \item General edge weights: Bellman-Ford's algorithm takes \(O\left( mn^2 \right) \) time, which can be \(\Theta \left( n^4 \right) \) when \(m = \Theta \left( n^2 \right) \). 
  \item Acyclic: Lawler's algorithm takes \(O(mn)\) time. 
  \item Non-negative edge weights: Dijkstra's takes \(O \left( mn + n^2 \log n \right) \) time.    
\end{itemize}

However, naive method takes a lot of time to compute unnecessary things, so it takes a lot of times.

\section{A DP algorithm}

\begin{definition}
  Let \(w_k(i, j)\) be the length of a shortest \((i, j)\)-path having at most \(k\) edges. Let it be \(\infty \) if such a path does not exist.
\end{definition}

We have 
  \begin{align*}
    w_1(i, j) &= w(ij) \text{ if } (i, j) \text{ if a edge, otherwise } w_1(i, j) = \infty. \\
    w_{n-1}(i, j) &= d_G(i, j) \text{ since a shortest path has at most } n-1 \text{ edges (note that there is not negative cycle)}.    
  \end{align*}  
Hence, we have 
\[
  w_{2k} (i, j) = \min _{1 \le t \le n} w_k(i, t) + w_k(t, j) \text{ for all } k \ge 1. 
\]
Also, note that even if \(k \ge \frac{n}{2}\) this recurrence relation is still correct, so we can just compute \(w_1(i, j)\) then \(w_2(i, j)\) then \(w_4(i, j)\) and so on, and after \(O\left( \log n \right) \) rounds we can get the answer. 

Now we analyze the time complexity. For each \((i, j)\)-pair, we need \(O(\log n)\) rounds, where each round takes \(O(n)\) times, so each \((i, j)\)-pair takes \(O(n \log n)\) times. Note that we have \(O \left( n^2 \right) \) \((i, j)\)-pairs, so it takes totally \(O\left( n^3 \log n \right) \) times. This is pretty slow, but in general a little bit faster than doing Bellman-Ford's algorithm for \(n\) times. 

\section{Floyd and Warshall's DP algorithm}
\begin{definition}
  Let \(d_k(i, j)\) be the length of any shortest \((i, j)\)-path whose \textcolor{red}{internal indices are at most \(k\)}. If there is no such a path, then let \(d_k(i, j) = \infty \).   
\end{definition}
\begin{figure}[H]
  \centering
  \incfig{internalnode}
  \caption{Internal Nodes}
  \label{fig:internal node}
\end{figure}
Thus, we have 
\[
  d_0(i, j) = w(ij), \quad d_n(i, j) = d_G(i, j).
\]
Hence, we can define a recurrence relation: 
\[
  \begin{dcases}
    d_0(i, j) = w(i, j) \\
    d_{k+1}(i, j) = \min \left\{ d_k(i, j), d_k(i, k+1) + d_k(k+1, j) \right\}.
  \end{dcases}
\]
Note that it corresponds to two cases: walk through \(k+1\) or not. If not, then it corresponds to \(d_k(i, j)\). If so, then it corresponds to \(d_k(i, k+1) + d_k(k+1, j)\) since excluding \(k+1\) and seperate this path into two parts, then internal nodes in each part can have indices of at most \(k\). 

Now we analyze the time complexity of Floyd and Warshall's DP algorithm: Fix \((i, j)\), then it takes \(O(n)\) time to compute from \(d_0(i, j)\) to \(d_{n}(i, j)\), and since we have \(O \left( n^2 \right) \) \((i, j)\)-pairs, so it take totally \(O \left( n^3 \right) \) time. 

\section{Johnson's reweighting technique}
As previously seen, if \(G\) is a non-negative weighted graph, then running Dijkstra's algorithm for \(n\) times needs \(O(mn + n \log n)\) time. Now Johnson gives a method to reweight \(w\) into \(\hat{w} \) s.t. 
\begin{itemize}
  \item \(\hat{w} \) is non-negative
  \item any shortest \((i, j)\)-path of \(G\) w.r.t. \(\hat{w} \) is a shortest \((i, j)\)-path of \(G\) w.r.t. \(w\).       
\end{itemize}    

The idea of reweighting is to 
\begin{itemize}
  \item Assign a weight \(h(i)\) to each vertex \(i\) of \(G\). 
  \item Let \(\hat{w} (i, j) = w(i, j) + h(i) - h(j)\). 
  \item Then, for any \((i, j)\)-path \(P\), we have 
  \[
    \hat{w} (P) = w(P) + h(i) - h(j).
  \]
  \item Hence, \(P\) is a shortest \((i,j)\)-path of \(G\) w.r.t. \(\hat{w} \) if and only if \(P\) is a shortest \((i, j)\)-path of \(G\) w.r.t. \(w\).        
\end{itemize}
\begin{remark}
  The challenge is to find a vertex weight \(h\) s.t. the resulting adjusted edge weight \(\hat{w} \) is non-negative. If \(\hat{w} \) is non-negative, then we can apply Dijkstra's algorithm to obtain all-pairs shortest path trees in \(O \left( mn + n^2 \log n \right) \) time.   
\end{remark}

\begin{algorithm}[H]
  \DontPrintSemicolon{}
  \caption{Johnson's Technique}
  Let \(H\) be obtained from \(G\) by adding a new vertex \(0\) and adding a weight-\(0\) edge from vertex \(0\) to each vertex \(i\) of \(G\). \\
  \(H\) has no negative cycle if and only if \(G\) has no negative cycle. \\
  Let \(h(i)\) be the distance from vertex \(0\) to vertex \(i\) in \(H\). That is, \(h(i) = d_H(0, i)\). \\
  The vertex weight function \(h\) can be obtained by Bellman-Ford in \(O(mn)\) time.  
\end{algorithm}

\begin{remark}
  \(H\) has no negative cycle if and only if \(G\) has no negative cycle since \(G\) is directed and vertex \(0\) has only out degree, so any cycle in \(H\) and \(G\) is induced by \(\left\{ 1,2,\dots ,n \right\} \), which does not include \(0\).        
\end{remark}

\begin{remark}
  \(d_H(0, i) \le 0\) and \(d_H(0, i) < 0\) if there is a path of negative weight from \(j\) to \(i\) for some \(j > 0\) since we can go from \(0\) to \(j\) first, then go from \(j\) to \(i\).         
\end{remark}

\begin{theorem}
  \(\hat{w} (i, j) \ge 0\) for all \(i, j \in [n]\).  
\end{theorem}
\begin{proof}
  Since 
  \[
    \hat{w} (i, j) = w(i, j) + h(i) - h(j) = w(i, j) + d_H(0, i) - d_H(0, j),
  \]
  and note that \(d_H(0, i) + w(i, j)\) is the shortest distance of a path from \(0\) and go through \(i\) to \(j\), which is \(\ge\) the distance from \(0\) to \(j\), which is \(d_H(0, j)\). Hence, we have 
  \[
    d_H(0, i) + w(i, j) - d_H(0, j) \ge 0.
  \]       
\end{proof}

Now we analyze the time complexity of Johnson's algorithm for general edge weights: We first obtain \(h\) by doing one time Bellman-Ford's algorithm, which takes \(O(mn)\) time. Then, we run Dijkstra's algorithm for all vertex \(i\) of \(G\), which takes totally \(O\left( mn + n^2 \log n \right) \) time. Note that to here we just store \(n\) shortest path tree, and we have to obtain the real distance by running through all \(n\) tree, which takes \(O(n) \cdot n = O \left( n^2 \right) \) time since a tree has \(n-1\) edges. Hence, it totally take \(O\left( mn + n^2 \log n \right) \) time for Johnson's technique.      

\chapter{Maximum flow}
\begin{problem}[The maximum flow problem]
\vphantom{text}
\begin{itemize}
  \item Input: A directed graph \(G\) with edge capacity \(c:E(G) \to \mathbb{R} ^+\) and two vertices, the source \(s\) and the sink \(t\). 
  \item Output: An \((s,t)\)-flow with maximum (flow) value.     
\end{itemize}
\end{problem}

\begin{remark}
  For convenience, we allow \(G\) has multiple/parallel edges, though merging multiple edges and increase the capacity to get an equivalent graph is not forbbiden.  
\end{remark}

\begin{remark}
  An \((s,t)\)-flow is a function \(f: E(G) \to \mathbb{R} ^+ \cup \left\{ 0 \right\} \) satisfying 
  \begin{itemize}
    \item capacity constraint: \(f(uv) \le c(uv)\) for each edge \(uv\) of \(G\). 
    \item conservation law: 
    \[
      \sum_{uv \in E(G)} f(uv) = \sum_{vw \in E(G)} f(vw)  
    \] for each vertex \(v\) of \(G\) other than \(s\) and \(t\).    
  \end{itemize}  
  The value of an \((s,t)\)-flow \(f\) is 
  \[
    \sum_{sv \in E(G)} f(sv) - \sum_{us \in E(G)} f(us).  
  \]  
\end{remark}
\begin{figure}[H]
  \centering
  \incfig{maxf}
  \caption{The maximum flow problem}
  \label{fig:maxf}
\end{figure}
\newpage

\section{Ford-Fulkerson's algorithm}
\begin{intuition}
  Reduce the mainum \((s, t)\)-flow problem to the reachability problems for a sequence of graph \(R\).  
\end{intuition}

\begin{definition}[Residual graph]
  The residual graph \(R(f)\) with respect to a flow \(f\) of \(G\) with \(V(R(f)) = V(G)\) is defined as follows for each edge \(uv\) of \(G\): 
  \begin{itemize}
    \item If \(f(uv) < c(fg)\), then let \(R(f)\) have an edge \(\textcolor{red}{uv}\) with capacity \(c(uv) - f(uv)\). 
    \item If \(f(uv) > 0\), then let \(R(f)\) have an edge \(\textcolor{blue}{vu}\) with capacity \(f(uv)\).        
  \end{itemize}      
\end{definition}

\begin{corollary}
  \(R(f)\) is a graph with capacity of every edge positive, just like \(G\).  
\end{corollary}

\begin{remark}
  Even if \(G\) has only one \(uv\) edge, \(R(f)\) may have \(2\) \(uv\) edges if \(f(uv) < c(uv)\) and \(f(vu) > 0\).       
\end{remark}

\begin{theorem}
  For any \((s, t)\)-flow \(f\) of \(G\), we have the following statements: 
  \begin{itemize}
    \item [(1)] If \(d_{R(f)}(s, t) = \infty \), then \(f\) is a maximum \((s, t)\)-flow of \(G\). 
    \item [(2)] If \(d_{R(f)}(s, t) < \infty \) and \(g\) is an \((s, t)\)-flow of the residual graph \(R(f)\), then \(f + g\) remains an \((s, t)\)-flow of \(G\), where 
    \[
      (f + g)(uv) = f(uv) + g(uv) - g(vu)
    \] for each edge \(uv\) of \(G\).  
  \end{itemize}   
\end{theorem}